name: "üöÄ Vayvy's Ultimate RDP Playground üåü"

on:
  workflow_dispatch:
    inputs:
      rdp_username:
        description: "üî• Desired RDP Username (e.g., VayvyUser)"
        required: true
        default: "VayvyUser"
      rdp_password:
        description: "üîí Strong RDP Password (min 12 chars, incl. special)"
        required: true
        default: "Vayvy@Secure2024" # Default for convenience, user should change
      rdp_enable_max_performance:
        description: "‚ö° Maximize RDP Performance (True/False - Experimental)"
        required: true
        default: "True"
      rdp_install_mumu:
        description: "üéÆ Install MuMu Player 5 (True/False)"
        required: true
        default: "True"
      discord_notify_on_finish:
        description: "üîî Send Discord Notification on Completion (True/False)"
        required: true
        default: "True"

env:
  DISCORD_WEBHOOK: "https://discord.com/api/webhooks/1421078099763789845/u1bE8nK9wIBfMR1pii65HsQqb28BfcF65VMaLzurUGtIoaKeYg1Eb67gLG9aLdWCJ0MM"
  KEEP_ALIVE_MINUTES: 720 # Runner will stay active for 12 hours
  EMULATOR_BOOT_WAIT_SECONDS: 90
  EMULATOR_POLL_RETRIES: 6
  DOWNLOAD_TRIES: 4
  MIN_VALID_BYTES: 2000000 # Minimum expected size for MuMu installer
  RDP_WM_TEXT: "VayVy RDP - Made with üíñ"
  # User can override username and password from workflow_dispatch inputs
  RDP_USER_INPUT: ${{ github.event.inputs.rdp_username }}
  RDP_PASS_INPUT: ${{ github.event.inputs.rdp_password }}
  RDP_MAX_PERFORMANCE: ${{ github.event.inputs.rdp_enable_max_performance }}
  RDP_INSTALL_MUMU: ${{ github.event.inputs.rdp_install_mumu }}
  DISCORD_NOTIFY_ON_FINISH: ${{ github.event.inputs.discord_notify_on_finish }}

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: ${{ env.KEEP_ALIVE_MINUTES }} # Use environment variable for timeout

    steps:
      - name: üåüüöÄ Vayvy's RDP Boot-up Sequence Initiated üöÄüåü
        run: |
          Write-Host "üöÄ Workflow started by: ${{ github.actor }}"
          Write-Host "‚è∞ Current UTC Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')"
          Write-Host "üñ•Ô∏è Runner OS: ${{ runner.os }}"
          Write-Host "‚è≥ Max RDP Uptime: ${{ env.KEEP_ALIVE_MINUTES }} minutes"
          Write-Host ""

      - name: ‚öôÔ∏è Configure Core RDP Settings
        run: |
          Write-Host "‚û°Ô∏è Step: Configuring Remote Desktop Services..."
          # Enable Remote Desktop and disable Network Level Authentication (if needed)
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' `
                             -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
                             -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' `
                             -Name "SecurityLayer" -Value 0 -Force

          # Remove any existing rule with the same name to avoid duplication
          netsh advfirewall firewall delete rule name="RDP-Tailscale"
          
          # For testing, allow any incoming connection on port 3389
          netsh advfirewall firewall add rule name="RDP-Tailscale" `
            dir=in action=allow protocol=TCP localport=3389

          # (Optional) Restart the Remote Desktop service to ensure changes take effect
          Restart-Service -Name TermService -Force
          Write-Host "‚úÖ RDP Core Settings Configured Successfully."

      - name: üîí Create RDP User with Secure Password
        run: |
          Write-Host "‚û°Ô∏è Step: Creating Secure RDP User Account..."
          $rdpUser = "${{ env.RDP_USER_INPUT }}"
          $rdpPass = "${{ env.RDP_PASS_INPUT }}"

          # Validate password complexity (optional, but good practice)
          if ($rdpPass.Length -lt 12 -or `
              ($rdpPass -notmatch '\p{Lu}') -or `
              ($rdpPass -notmatch '\p{Ll}') -or `
              ($rdpPass -notmatch '\p{N}') -or `
              ($rdpPass -notmatch '\p{S}')) {
              Write-Warning "‚ö†Ô∏è Provided password might not meet complexity requirements (min 12 chars, incl. uppercase, lowercase, number, special). Attempting to use it anyway."
          }

          $securePass = ConvertTo-SecureString $rdpPass -AsPlainText -Force
          
          # Check if user already exists
          if (Get-LocalUser -Name $rdpUser -ErrorAction SilentlyContinue) {
              Write-Host "User '$rdpUser' already exists. Updating password and group memberships."
              Set-LocalUser -Name $rdpUser -Password $securePass -AccountNeverExpires
          } else {
              New-LocalUser -Name $rdpUser -Password $securePass -AccountNeverExpires
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $rdpUser
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $rdpUser
          
          echo "RDP_USERNAME=$rdpUser" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$rdpPass" >> $env:GITHUB_ENV # Store for Discord webhook, handle securely
          
          if (-not (Get-LocalUser -Name $rdpUser)) {
              Write-Error "User creation failed for '$rdpUser'."
              exit 1
          }
          Write-Host "‚úÖ RDP User '$rdpUser' Created/Updated Successfully."

      - name: üöÄ Optimize RDP for Maximum Performance (Vayvy's Touch)
        if: env.RDP_MAX_PERFORMANCE == 'True'
        run: |
          Write-Host "‚û°Ô∏è Step: Applying Performance Optimizations for a Smooth RDP Experience..."
          
          # Disable visual effects for performance
          Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name "UserPreferencesMask" -Value ([byte[]](0x90, 0x12, 0x01, 0x80, 0x10, 0x00, 0x00, 0x00)) -Force
          Set-ItemProperty -Path "HKCU:\Control Panel\Desktop\WindowMetrics" -Name "MinAnimate" -Value "0" -Force

          # Set RDP connection settings for low bandwidth (graphics quality)
          Set-ItemProperty -Path 'HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services' -Name "fEnforceClientDesktopComposition" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\Terminal Services' -Name "fAllowUnsafeRemoteConnections" -Value 1 -Force # Less secure, but for performance
          
          # Disable unnecessary services (use with caution, for max performance on a dedicated RDP)
          # Stop-Service -Name "SysMain" -ErrorAction SilentlyContinue # Superfetch
          # Stop-Service -Name "DiagTrack" -ErrorAction SilentlyContinue # Connected User Experiences and Telemetry
          # Set-Service -Name "SysMain" -StartupType Disabled -ErrorAction SilentlyContinue
          # Set-Service -Name "DiagTrack" -StartupType Disabled -ErrorAction SilentlyContinue

          # Set power plan to High Performance
          powercfg /setactive 8c5e7fd1-ce92-4676-a201-0ed67ee1c238 # High Performance GUID
          
          # Registry tweaks for better RDP display
          Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "MaxLossyCompression" -Value 2 -Force # Maximize compression
          Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "MaxBMPCacheSize" -Value 65536 -Force # Larger cache
          
          Write-Host "‚úÖ RDP Performance Optimizations Applied."

      - name: üåê Install Tailscale VPN
        run: |
          Write-Host "‚û°Ô∏è Step: Installing Tailscale VPN Client..."
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-1.82.0-amd64.msi" # Ensure this is the latest stable
          $installerPath = "$env:TEMP\tailscale.msi"
          
          Invoke-WebRequest -Uri $tsUrl -OutFile $installerPath
          Start-Process msiexec.exe -ArgumentList "/i", "`"$installerPath`"", "/quiet", "/norestart" -Wait
          Remove-Item $installerPath -Force
          Write-Host "‚úÖ Tailscale Installation Complete."

      - name: üîë Establish Tailscale Connection & Get IP
        run: |
          Write-Host "‚û°Ô∏è Step: Connecting to Tailscale Network..."
          
          # Bring up Tailscale with the provided auth key and set a unique hostname
          # The hostname includes the workflow run ID for easy identification
          & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=Vayvy-RDP-gh-${{ github.run_id }} --advertise-routes=0.0.0.0/0,::/0 # Advertise all routes for full access (use with caution)
          
          # Wait for Tailscale to assign an IP and provide public IP
          $tsIP = $null
          $publicIP = $null
          $retries = 0
          while (-not $tsIP -and $retries -lt 15) { # Increased retries
              Write-Host "Attempting to get Tailscale IP (Retry: $($retries+1))..."
              $tsIP = (& "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4).Trim()
              if ($tsIP) {
                  Write-Host "Tailscale IP found: $tsIP"
              } else {
                  Start-Sleep -Seconds 10
              }
              $retries++
          }
          
          if (-not $tsIP) {
              Write-Error "Tailscale IP not assigned after multiple retries. Exiting."
              echo "Failed to get Tailscale IP." | Out-File -FilePath discord_error.txt
              exit 1
          }

          $publicIP = (Invoke-RestMethod -Uri "http://ipecho.net/plain").Trim()
          if (-not $publicIP) {
              $publicIP = "Unknown (Failed to retrieve)"
          }

          # Get RDP Location (simplified, based on public IP location)
          $locationInfo = Invoke-RestMethod -Uri "http://ip-api.com/json/$publicIP?fields=country,regionName,city,lat,lon"
          $rdpLocation = "$($locationInfo.city), $($locationInfo.regionName), $($locationInfo.country) (Lat: $($locationInfo.lat), Lon: $($locationInfo.lon))"

          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
          echo "PUBLIC_IP=$publicIP" >> $env:GITHUB_ENV
          echo "RDP_LOCATION=$rdpLocation" >> $env:GITHUB_ENV
          
          Write-Host "‚úÖ Tailscale Connected and IPs Retrieved."

      - name: üîç Verify RDP Accessibility
        run: |
          Write-Host "‚û°Ô∏è Step: Verifying RDP Service Accessibility..."
          Write-Host "Tailscale IP: $env:TAILSCALE_IP"
          
          # Test connectivity using Test-NetConnection against the Tailscale IP on port 3389
          $testResult = Test-NetConnection -ComputerName $env:TAILSCALE_IP -Port 3389 -ErrorAction SilentlyContinue
          if (-not $testResult.TcpTestSucceeded) {
              Write-Error "TCP connection to RDP port 3389 failed via Tailscale IP."
              echo "RDP service not accessible via Tailscale IP." | Out-File -FilePath discord_error.txt
              exit 1
          }
          Write-Host "‚úÖ TCP Connectivity to RDP Port 3389 (via Tailscale) Successful!"

      - name: üñºÔ∏è Set Desktop Background with Watermark (Vayvy's Signature)
        run: |
          Write-Host "‚û°Ô∏è Step: Applying Custom Desktop Background with Vayvy Watermark..."
          $script = @'
          # PowerShell script to set desktop background with watermark
          $watermarkText = "$env:RDP_WM_TEXT"
          $imagePath = "$env:TEMP\Vayvy_RDP_Background.bmp"

          # Create a blank image to draw on (e.g., 1920x1080)
          $width = 1920
          $height = 1080

          Add-Type -AssemblyName System.Drawing
          $bmp = New-Object System.Drawing.Bitmap($width, $height)
          $graphics = [System.Drawing.Graphics]::FromImage($bmp)
          
          # Fill with a solid color (e.g., dark blue)
          $graphics.FillRectangle([System.Drawing.Brushes]::DarkSlateGray, 0, 0, $width, $height)

          # Set font and color for watermark
          $font = New-Object System.Drawing.Font("Arial", 48, [System.Drawing.FontStyle]::Bold)
          $brush = New-Object System.Drawing.SolidBrush([System.Drawing.Color]::FromArgb(100, 255, 255, 255)) # Semi-transparent white
          
          # Measure string for centering/positioning
          $stringSize = $graphics.MeasureString($watermarkText, $font)
          
          # Draw watermark multiple times diagonally for "unremovable" effect
          for ($x = -500; $x -lt $width + 500; $x += 400) {
              for ($y = -200; $y -lt $height + 200; $y += 300) {
                  $graphics.TranslateTransform($x, $y)
                  $graphics.RotateTransform(-25) # Rotate for diagonal effect
                  $graphics.DrawString($watermarkText, $font, $brush, 0, 0)
                  $graphics.ResetTransform()
              }
          }

          $graphics.Dispose()
          
          # Save the image as BMP (better compatibility for desktop background)
          $bmp.Save($imagePath, [System.Drawing.Imaging.ImageFormat]::Bmp)
          $bmp.Dispose()

          # Set the desktop background
          Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name WallPaper -Value $imagePath -Force
          Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name TileWallpaper -Value 0 -Force # Center
          Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name WallpaperStyle -Value 2 -Force # Stretch/Fill
          
          # Update desktop
          RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters 1, True
          '@
          $script | Out-File -FilePath "$env:TEMP\SetWallpaper.ps1"
          powershell -File "$env:TEMP\SetWallpaper.ps1" -ExecutionPolicy Bypass
          Write-Host "‚úÖ Watermark Background Applied Successfully. (This might not be visible in headless runners but will be on RDP login)."

      - name: üéÆ Install MuMu Player 5 (Vayvy's Gaming Touch)
        if: env.RDP_INSTALL_MUMU == 'True'
        run: |
          Write-Host "‚û°Ô∏è Step: Installing MuMu Player 5..."
          $mumuUrl = "https://github.com/VaySagab/fixit/releases/download/file/MuMu_5.0.4_pi0eurC.exe"
          $installerPath = "$env:TEMP\MuMu_5.0.4.exe"
          $maxRetries = [int]$env:DOWNLOAD_TRIES
          $minBytes = [long]$env:MIN_VALID_BYTES
          $downloadSuccess = $false

          for ($i = 1; $i -le $maxRetries; $i++) {
              Write-Host "Attempting to download MuMu Player (Attempt $i/$maxRetries)..."
              try {
                  Invoke-WebRequest -Uri $mumuUrl -OutFile $installerPath -TimeoutSec 300 # 5 minute timeout
                  $fileSize = (Get-Item $installerPath).Length
                  if ($fileSize -ge $minBytes) {
                      Write-Host "Download successful and file size ($fileSize bytes) is valid."
                      $downloadSuccess = $true
                      break
                  } else {
                      Write-Warning "Downloaded file size ($fileSize bytes) is too small. Retrying..."
                      Remove-Item $installerPath -ErrorAction SilentlyContinue
                  }
              } catch {
                  Write-Warning "Download failed: $($_.Exception.Message). Retrying..."
                  Remove-Item $installerPath -ErrorAction SilentlyContinue
              }
              Start-Sleep -Seconds 10
          }

          if (-not $downloadSuccess) {
              Write-Error "Failed to download MuMu Player after $maxRetries attempts. Installation skipped."
              echo "Failed to download MuMu Player. Check URL or network." | Out-File -FilePath discord_error.txt
              exit 1 # Consider if this should be a critical error or just skip MuMu
          }
          
          Write-Host "Starting MuMu Player installation. This may take a while..."
          # Use /S for silent installation if supported, or adapt to the installer's silent options
          Start-Process $installerPath -ArgumentList "/S", "/Passive" -Wait -NoNewWindow -ErrorAction Stop
          Remove-Item $installerPath -Force -ErrorAction SilentlyContinue # Clean up installer
          
          Write-Host "‚úÖ MuMu Player 5 Installation Attempted. Please verify upon RDP login."
          Write-Host "Note: MuMu Player might require additional configuration or updates on first run."

      - name: üì¢ Discord Webhook Notification - RDP Ready!
        run: |
          if ("${{ env.DISCORD_NOTIFY_ON_FINISH }}" -eq "True") {
            Write-Host "‚û°Ô∏è Step: Sending Discord RDP Ready Notification..."
            $jsonBody = @{
                username = "Vayvy's RDP Bot ü§ñ"
                avatar_url = "https://i.imgur.com/your_bot_avatar.png" # Replace with a cool Vayvy bot avatar
                embeds = @(
                    @{
                        title = "üéâ Vayvy's RDP Is Live! Connect Now! üéâ"
                        description = "Your personalized RDP environment is ready for action! Get ready to explore."
                        color = 65280 # Green color
                        fields = @(
                            @{ name = "üëë RDP Username"; value = "`\`\`${{ env.RDP_USERNAME}}\`\``"; inline = $true },
                            @{ name = "üîë RDP Password"; value = "`\`\`${{ env.RDP_PASSWORD}}\`\``"; inline = $true },
                            @{ name = "üåê Tailscale IP"; value = "`\`\`${{ env.TAILSCALE_IP}}\`\``"; inline = $true },
                            @{ name = "üåç Public IP"; value = "`\`\`${{ env.PUBLIC_IP}}\`\``"; inline = $true },
                            @{ name = "üìç RDP Location"; value = "`\`\`${{ env.RDP_LOCATION}}\`\``"; inline = $true },
                            @{ name = "üîó Tailscale Connect Guide"; value = "1. Install [Tailscale](https://tailscale.com/download).\n2. Login with the same account as your auth key.\n3. Ping `${{ env.TAILSCALE_IP}}` to confirm connection.\n4. Connect with an RDP client to `${{ env.TAILSCALE_IP}}` using the provided credentials." }
                        )
                        footer = @{
                            text = "RDP Made by Vayvy | Workflow ID: ${{ github.run_id }}"
                            icon_url = "https://i.imgur.com/your_vayvy_logo.png" # Replace with a cool Vayvy logo
                        }
                        timestamp = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                    }
                )
            } | ConvertTo-Json -Depth 4

            try {
                Invoke-RestMethod -Uri "${{ env.DISCORD_WEBHOOK }}" -Method Post -ContentType "application/json" -Body $jsonBody
                Write-Host "‚úÖ RDP Ready notification sent to Discord."
            } catch {
                Write-Warning "‚ö†Ô∏è Failed to send Discord RDP Ready notification: $($_.Exception.Message)"
                echo "Failed to send RDP Ready Discord notification." | Out-File -FilePath discord_error.txt
            }
          } else {
            Write-Host "üö´ Discord notification for RDP Ready is disabled."
          }

      - name: üìä Start RDP Monitoring and Keep Alive
        run: |
          Write-Host ""
          Write-Host "****************************************************************"
          Write-Host "***               RDP READY FOR CONNECTION!                ***"
          Write-Host "****************************************************************"
          Write-Host "***        Your Vayvy RDP is now fully operational!        ***"
          Write-Host "***                                                        ***"
          Write-Host "***   Tailscale IP:   $env:TAILSCALE_IP"
          Write-Host "***   Username:       $env:RDP_USERNAME"
          Write-Host "***   Password:       $env:RDP_PASSWORD"
          Write-Host "***                                                        ***"
          Write-Host "***   Session Duration: $env:KEEP_ALIVE_MINUTES minutes    ***"
          Write-Host "***   Cancel workflow on GitHub to terminate               ***"
          Write-Host "****************************************************************"
          Write-Host "***         System monitoring active on Discord            ***"
          Write-Host "****************************************************************"
          Write-Host ""
          
          $discordWebhook = "${{ env.DISCORD_WEBHOOK }}"
          $runnerHostname = "$env:COMPUTERNAME"
          $monitoringIntervalSeconds = 3600 # Every 1 hour
          $crashThresholdCPU = 90 # % CPU
          $crashThresholdRAM = 90 # % RAM usage
          $lastCpuAlert = [DateTime]::MinValue
          $lastRamAlert = [DateTime]::MinValue
          $alertCooldownSeconds = 300 # 5 minutes cooldown for crash alerts

          function Send-DiscordMonitoringNotification {
              param (
                  [string]$title,
                  [string]$description,
                  [int]$color,
                  [hashtable]$fields = @{},
                  [string]$footerText = "Vayvy RDP Monitoring"
              )
              
              $embedFields = @()
              foreach ($key in $fields.Keys) {
                  $embedFields += @{ name = $key; value = $fields[$key]; inline = $true }
              }

              $jsonBody = @{
                  username = "Vayvy's RDP Monitor üìä"
                  avatar_url = "https://i.imgur.com/your_monitor_avatar.png" # Replace with cool monitor bot avatar
                  embeds = @(
                      @{
                          title = $title
                          description = $description
                          color = $color
                          fields = $embedFields
                          footer = @{
                              text = "$footerText | Runner: $runnerHostname | Workflow: ${{ github.run_id }}"
                              icon_url = "https://i.imgur.com/your_vayvy_logo.png"
                          }
                          timestamp = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                      }
                  )
              } | ConvertTo-Json -Depth 4

              try {
                  Invoke-RestMethod -Uri $discordWebhook -Method Post -ContentType "application/json" -Body $jsonBody -TimeoutSec 30
                  Write-Host "[$(Get-Date)] Discord monitoring notification sent: $title"
              } catch {
                  Write-Warning "[$(Get-Date)] ‚ö†Ô∏è Failed to send Discord monitoring notification: $($_.Exception.Message)"
              }
          }

          function Get-SystemMetrics {
              $cpu = (Get-Counter '\Processor(_Total)\% Processor Time').CounterSamples.Where({ $_.InstanceName -eq '_total' }).CookedValue
              $memory = Get-WmiObject -Class Win32_OperatingSystem
              $totalMemoryMB = [math]::Round($memory.TotalPhysicalMemory / 1024)
              $freeMemoryMB = [math]::Round($memory.FreePhysicalMemory / 1024)
              $usedMemoryMB = $totalMemoryMB - $freeMemoryMB
              $ramUsagePercent = [math]::Round(($usedMemoryMB / $totalMemoryMB) * 100, 2)
              
              [PSCustomObject]@{
                  CPU = [math]::Round($cpu, 2)
                  TotalRAM = $totalMemoryMB
                  UsedRAM = $usedMemoryMB
                  FreeRAM = $freeMemoryMB
                  RAMUsagePercent = $ramUsagePercent
              }
          }

          $monitoringStartTime = Get-Date
          $lastHourlyCheck = Get-Date

          while ($true) {
              $currentMetrics = Get-SystemMetrics
              $cpuLoad = $currentMetrics.CPU
              $ramUsage = $currentMetrics.RAMUsagePercent
              $currentTime = Get-Date

              Write-Host "[$(Get-Date)] System Status - CPU: $($cpuLoad)% | RAM: $($ramUsage)% ($($currentMetrics.UsedRAM)MB / $($currentMetrics.TotalRAM)MB)"

              # Hourly Monitoring
              if (($currentTime - $lastHourlyCheck).TotalSeconds -ge $monitoringIntervalSeconds) {
                  Send-DiscordMonitoringNotification -title "üìä Hourly RDP System Report" `
                      -description "Just a quick check-in on your Vayvy RDP!" `
                      -color 3447003 ` # Blue
                      -fields @{
                          "CPU Usage" = "$($cpuLoad)%";
                          "RAM Usage" = "$($ramUsage)% ($($currentMetrics.UsedRAM)MB / $($currentMetrics.TotalRAM)MB)";
                          "Time Active" = "$((New-TimeSpan -Start $monitoringStartTime -End $currentTime).ToString('hh\:mm\:ss'))";
                          "Public IP" = "${{ env.PUBLIC_IP }}";
                          "Tailscale IP" = "${{ env.TAILSCALE_IP }}"
                      }
                  $lastHourlyCheck = $currentTime
              }

              # Crash Prevention Monitoring (High CPU/RAM)
              if ($cpuLoad -ge $crashThresholdCPU -and ($currentTime - $lastCpuAlert).TotalSeconds -ge $alertCooldownSeconds) {
                  Send-DiscordMonitoringNotification -title "üö® WARNING: High CPU Usage!" `
                      -description "Your Vayvy RDP is experiencing high CPU load, potentially nearing a crash." `
                      -color 16763904 ` # Orange
                      -fields @{
                          "Current CPU" = "$($cpuLoad)%";
                          "Threshold" = "$($crashThresholdCPU)%";
                          "Recommended Action" = "Check running applications on your RDP."
                      }
                  $lastCpuAlert = $currentTime
              }

              if ($ramUsage -ge $crashThresholdRAM -and ($currentTime - $lastRamAlert).TotalSeconds -ge $alertCooldownSeconds) {
                  Send-DiscordMonitoringNotification -title "üö® WARNING: High RAM Usage!" `
                      -description "Your Vayvy RDP is consuming a lot of RAM, potentially leading to instability." `
                      -color 16729344 ` # Red
                      -fields @{
                          "Current RAM Usage" = "$($ramUsage)% ($($currentMetrics.UsedRAM)MB / $($currentMetrics.TotalRAM)MB)";
                          "Threshold" = "$($crashThresholdRAM)%";
                          "Recommended Action" = "Close unnecessary applications or reduce memory-intensive tasks."
                      }
                  $lastRamAlert = $currentTime
              }

              Start-Sleep -Seconds 60 # Check every minute for alerts, hourly for full report
          }
        env:
          # Pass Discord webhook to this step, ensuring it's available for the script
          DISCORD_WEBHOOK: ${{ env.DISCORD_WEBHOOK }}
        # This step handles errors locally if Send-DiscordMonitoringNotification fails, but allows the main loop to continue.

      - name: ‚ùå Discord Webhook Notification - Workflow Failed
        if: ${{ failure() && env.DISCORD_NOTIFY_ON_FINISH == 'True' }}
        run: |
          $discordWebhook = "${{ env.DISCORD_WEBHOOK }}"
          $errorMessage = "An unexpected error occurred during the RDP setup. Please check the workflow logs for details."
          $errorFile = "discord_error.txt"
          if (Test-Path $errorFile) {
              $errorMessage = Get-Content $errorFile -Raw
          }

          $jsonBody = @{
              username = "Vayvy's RDP Bot ü§ñ"
              avatar_url = "https://i.imgur.com/your_bot_avatar.png"
              embeds = @(
                  @{
                      title = "‚ùå Vayvy's RDP Setup Failed!"
                      description = "Uh oh! Something went wrong while setting up your Vayvy RDP. Please review the logs to diagnose the issue."
                      color = 16711680 # Red color
                      fields = @(
                          @{ name = "Workflow ID"; value = "`\`\`${{ github.run_id}}\`\``"; inline = $true },
                          @{ name = "Error Details"; value = "`\`\`\`$errorMessage\`\`\`\`" }
                      )
                      footer = @{
                          text = "Vayvy RDP Error | Check GitHub Actions logs"
                          icon_url = "https://i.imgur.com/your_vayvy_logo.png"
                      }
                      timestamp = "$(Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')"
                  }
              )
          } | ConvertTo-Json -Depth 4

          try {
              Invoke-RestMethod -Uri $discordWebhook -Method Post -ContentType "application/json" -Body $jsonBody
              Write-Host "‚úÖ Error notification sent to Discord."
          } catch {
              Write-Warning "‚ö†Ô∏è Failed to send Discord error notification: $($_.Exception.Message)"
          }
